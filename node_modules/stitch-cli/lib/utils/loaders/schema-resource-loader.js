"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const path_1 = require("path");
const globby = require("globby");
const graphql_1 = require("graphql");
const R = require("ramda");
async function default_1(schemaResource, resourceFile) {
    const schemaStrList = [];
    if (schemaResource.schema) {
        schemaStrList.push(schemaResource.schema);
    }
    if (schemaResource.schemaFiles) {
        const fileContents = await loadSchemaFiles(schemaResource.schemaFiles, resourceFile);
        schemaStrList.push(...fileContents);
    }
    const schemas = schemaStrList.map(s => graphql_1.parse(s));
    const schema = graphql_1.print(mergeSchemaDocuments(schemas));
    return {
        metadata: schemaResource.metadata,
        schema,
    };
}
exports.default = default_1;
async function loadSchemaFiles(schemaFiles, resourceFile) {
    const cwd = path_1.resolve(path_1.dirname(resourceFile));
    const files = await globby(schemaFiles, { cwd });
    return Promise.all(files.map(f => fs_1.promises.readFile(path_1.join(cwd, f), { encoding: 'utf8' })));
}
const rootObjectDefinitionTypes = ['Query', 'Mutation', 'Subscription'];
function mergeSchemaDocuments(schemas) {
    const allDefinitions = schemas.flatMap(s => s.definitions);
    const definitionGroups = R.groupBy(d => d.kind, allDefinitions);
    definitionGroups[graphql_1.Kind.OBJECT_TYPE_DEFINITION] = handleObjectTypeDefinitions(definitionGroups[graphql_1.Kind.OBJECT_TYPE_DEFINITION]);
    const definitions = R.pipe(R.values, R.flatten)(definitionGroups);
    return {
        kind: 'Document',
        definitions,
    };
}
function handleObjectTypeDefinitions(objectTypeDefinitions) {
    if (!objectTypeDefinitions)
        return [];
    const mergedTypes = [];
    rootObjectDefinitionTypes.forEach(rootType => handleRootType(rootType, objectTypeDefinitions, mergedTypes));
    const uniqueObjectTypeDefinitions = objectTypeDefinitions
        .filter(o => !rootObjectDefinitionTypes.includes(o.name.value))
        .concat(mergedTypes);
    const dupObjects = R.pipe(R.groupBy((o) => o.name.value), R.values, R.find(objs => objs.length > 1))(uniqueObjectTypeDefinitions);
    if (dupObjects) {
        throw new Error(`Duplicate object type definitions: ${dupObjects[0].name.value}`);
    }
    return uniqueObjectTypeDefinitions;
}
function handleRootType(typeName, objectTypeDefinitions, mergedTypes) {
    const rootTypes = objectTypeDefinitions.filter(o => o.name.value === typeName);
    if (rootTypes?.length >= 1) {
        mergedTypes.push(mergeObjectTypeDefinitions(rootTypes));
    }
}
function mergeObjectTypeDefinitions(typeDefs) {
    if (typeDefs.length === 1)
        return typeDefs[0];
    return {
        ...typeDefs[0],
        fields: typeDefs.flatMap(t => t.fields ?? []),
    };
}
