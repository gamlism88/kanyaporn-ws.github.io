"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const client_1 = require("../../client");
const list_resource_files_1 = require("../../utils/list-resource-files");
const read_resource_file_1 = require("../../utils/read-resource-file");
const get_env_info_1 = require("../../utils/get-env-info");
const printListItem = (f) => `  - ${f}`;
class ApplyResources extends command_1.Command {
    constructor() {
        super(...arguments);
        this.verboseMode = false;
    }
    async run() {
        const { args, flags } = this.parse(ApplyResources);
        const dryRun = flags['dry-run'];
        this.verboseMode = flags['verbose'];
        if (dryRun) {
            this.log(`Dry run mode ON - No changes will be made to the registry`);
        }
        try {
            const resourceTypesToSkip = flags['skip-resource-types']?.split(',');
            this.log(`Looking for resources at ${args.resourcesPath}...`);
            const resourceGroup = await this.pathToResourceGroup(args.resourcesPath, resourceTypesToSkip);
            const resourceCounts = Object.entries(resourceGroup).map(([key, value]) => ({ key, count: value?.length ?? 0 }));
            this.log('The following resources found:');
            resourceCounts.forEach(({ key, count }) => this.log(`  ${key}: ${count}${resourceTypesToSkip?.includes(key) ? ' - Skipped' : ''}`));
            this.log(`${dryRun ? 'Verifying' : 'Uploading'} resources...`);
            const { result: { success }, } = await client_1.uploadResourceGroup(resourceGroup, {
                registryUrl: flags['registry-url'],
                authorizationHeader: flags['authorization-header'],
                dryRun,
            }, {
                timeout: flags.timeout,
            });
            if (success) {
                this.log(`Resources from ${args.resourcesPath} were ${dryRun ? 'verified' : 'uploaded'} successfully.`);
            }
            else {
                throw new Error('Something went wrong');
            }
        }
        catch (e) {
            this.error(`${dryRun ? 'Verifying' : 'Uploading'} resources failed. ${e}

          ${get_env_info_1.default(this.config, 'apply:resources', flags['registry-url'], flags['authorization-header'])}`, { ...e, exit: true });
        }
    }
    async pathToResourceGroup(filePath, resourceTypesToSkip) {
        const rg = { schemas: [], upstreams: [], upstreamClientCredentials: [], policies: [] };
        const resourceFiles = await list_resource_files_1.default(filePath);
        this.trace(`Found ${resourceFiles.length} resource files:\n${resourceFiles.map(printListItem).join('\n')}`);
        this.trace('Loading resources...');
        for (const resourceFile of resourceFiles) {
            this.trace(`  Loading resources from ${resourceFile}...`);
            const resourceMap = await read_resource_file_1.default(resourceFile, resourceTypesToSkip);
            this.trace('  The following resources loaded:');
            Object.entries(resourceMap).forEach(([kind, resources]) => this.trace('  ' + printListItem(`${kind}: ${resources?.length ?? 0}`)));
            this.addToResourceGroup(resourceMap, rg);
        }
        return rg;
    }
    async addToResourceGroup(resourceMap, rg) {
        for (const kind in resourceMap) {
            const resourceList = resourceMap[kind];
            for (const resource of resourceList) {
                switch (kind) {
                    case 'Schema':
                        rg.schemas.push(resource);
                        continue;
                    case 'Upstream':
                        rg.upstreams.push(resource);
                        continue;
                    case 'UpstreamClientCredentials':
                        rg.upstreamClientCredentials.push(resource);
                        continue;
                    case 'Policy':
                        rg.policies.push(resource);
                        continue;
                    default:
                        this.log('Unknown resource kind', kind);
                        continue;
                }
            }
        }
    }
    async trace(message, ...args) {
        if (this.verboseMode) {
            this.log(message, ...args);
        }
    }
}
exports.default = ApplyResources;
ApplyResources.description = 'Apply resources';
ApplyResources.examples = [
    `$ stitch apply:resources schema.gql
Uploaded successfully!
`,
];
ApplyResources.flags = {
    'registry-url': command_1.flags.string({ required: true, env: 'STITCH_REGISTRY_URL', description: 'Url of the registry' }),
    'dry-run': command_1.flags.boolean({ required: false, default: false, description: 'Should perform a dry run' }),
    'authorization-header': command_1.flags.string({ required: false, description: 'Custom authorization header' }),
    'skip-resource-types': command_1.flags.string({ required: false, description: 'Resource types to skip' }),
    timeout: command_1.flags.integer({ required: false, default: 10000, description: 'Request timeout' }),
    verbose: command_1.flags.boolean({ required: false, default: false, description: 'Verbose mode' }),
};
ApplyResources.args = [{ name: 'resourcesPath', required: true }];
