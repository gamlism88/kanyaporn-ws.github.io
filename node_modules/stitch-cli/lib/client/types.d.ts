export declare type Maybe<T> = T | null;
export declare type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
/** All built-in and custom scalars, mapped to their actual values */
export declare type Scalars = {
    ID: string;
    String: string;
    Boolean: boolean;
    Int: number;
    Float: number;
    JSON: any;
    JSONObject: any;
};
export declare type ResourceMetadataInput = {
    namespace: Scalars['String'];
    name: Scalars['String'];
};
export declare type Result = {
    __typename?: 'Result';
    success: Scalars['Boolean'];
};
export declare type ResourceGroupInput = {
    schemas?: Maybe<Array<SchemaInput>>;
    upstreams?: Maybe<Array<UpstreamInput>>;
    upstreamClientCredentials?: Maybe<Array<UpstreamClientCredentialsInput>>;
    policies?: Maybe<Array<PolicyInput>>;
};
export declare type Query = {
    __typename?: 'Query';
    validateResourceGroup?: Maybe<Result>;
    validateSchemas?: Maybe<Result>;
    validateUpstreams?: Maybe<Result>;
    validateUpstreamClientCredentials?: Maybe<Result>;
    validatePolicies?: Maybe<Result>;
};
export declare type QueryValidateResourceGroupArgs = {
    input: ResourceGroupInput;
};
export declare type QueryValidateSchemasArgs = {
    input: Array<SchemaInput>;
};
export declare type QueryValidateUpstreamsArgs = {
    input: Array<UpstreamInput>;
};
export declare type QueryValidateUpstreamClientCredentialsArgs = {
    input: Array<UpstreamClientCredentialsInput>;
};
export declare type QueryValidatePoliciesArgs = {
    input: Array<PolicyInput>;
};
export declare type Mutation = {
    __typename?: 'Mutation';
    updateResourceGroup?: Maybe<Result>;
    updateSchemas?: Maybe<Result>;
    updateUpstreams?: Maybe<Result>;
    updateUpstreamClientCredentials?: Maybe<Result>;
    updatePolicies?: Maybe<Result>;
    updateBasePolicy?: Maybe<Result>;
    updateIntrospectionQueryPolicy?: Maybe<Result>;
};
export declare type MutationUpdateResourceGroupArgs = {
    input: ResourceGroupInput;
};
export declare type MutationUpdateSchemasArgs = {
    input: Array<SchemaInput>;
};
export declare type MutationUpdateUpstreamsArgs = {
    input: Array<UpstreamInput>;
};
export declare type MutationUpdateUpstreamClientCredentialsArgs = {
    input: Array<UpstreamClientCredentialsInput>;
};
export declare type MutationUpdatePoliciesArgs = {
    input: Array<PolicyInput>;
};
export declare type MutationUpdateBasePolicyArgs = {
    input: BasePolicyInput;
};
export declare type MutationUpdateIntrospectionQueryPolicyArgs = {
    input: BasePolicyInput;
};
export declare type SchemaInput = {
    metadata: ResourceMetadataInput;
    schema: Scalars['String'];
};
export declare enum AuthType {
    ActiveDirectory = "ActiveDirectory"
}
/**
 * GraphQL doesn't support unions for input types, otherwise this would be a union of different auth types.
 * Instead, the AuthType enum indicates which auth type is needed, and there's a property which corresponds to each auth type, which we validate in the registry.
 */
export declare type AuthInput = {
    type: AuthType;
    activeDirectory: ActiveDirectoryAuthInput;
};
export declare type ActiveDirectoryAuthInput = {
    authority: Scalars['String'];
    resource: Scalars['String'];
};
export declare type UpstreamInput = {
    metadata: ResourceMetadataInput;
    host: Scalars['String'];
    auth: AuthInput;
};
export declare type ActiveDirectoryCredentials = {
    authority: Scalars['String'];
    clientId: Scalars['String'];
    clientSecret: Scalars['String'];
};
/**
 * GraphQL doesn't support unions for input types, otherwise this would be a union of different auth types.
 * Instead, the AuthType enum indicates which auth type is needed, and there's a property which corresponds to each auth type, which we validate in the registry.
 */
export declare type UpstreamClientCredentialsInput = {
    metadata: ResourceMetadataInput;
    authType: AuthType;
    activeDirectory: ActiveDirectoryCredentials;
};
export declare enum PolicyType {
    Opa = "opa"
}
export declare type PolicyQueryInput = {
    gql: Scalars['String'];
    variables?: Maybe<Scalars['JSONObject']>;
};
export declare type PolicyInput = {
    metadata: ResourceMetadataInput;
    type: PolicyType;
    shouldOverrideBasePolicy?: Maybe<Scalars['Boolean']>;
    code: Scalars['String'];
    args?: Maybe<Scalars['JSONObject']>;
    query?: Maybe<PolicyQueryInput>;
};
export declare type BasePolicyInput = {
    namespace: Scalars['String'];
    name: Scalars['String'];
    args?: Maybe<Scalars['JSONObject']>;
};
